# Домашнее задание к занятию "3.3. Операционные системы, лекция 1"

1. Какой системный вызов делает команда `cd`? В прошлом ДЗ мы выяснили, что `cd` не является самостоятельной  программой, это `shell builtin`, поэтому запустить `strace` непосредственно на `cd` не получится. Тем не менее, вы можете запустить `strace` на `/bin/bash -c 'cd /tmp'`. В этом случае вы увидите полный список системных вызовов, которые делает сам `bash` при старте. Вам нужно найти тот единственный, который относится именно к `cd`.

   ` chdir("/tmp")`

3. Попробуйте использовать команду `file` на объекты разных типов на файловой системе. Например:
    ```bash
    vagrant@netology1:~$ file /dev/tty
    /dev/tty: character special (5/0)
    vagrant@netology1:~$ file /dev/sda
    /dev/sda: block special (8/0)
    vagrant@netology1:~$ file /bin/bash
    /bin/bash: ELF 64-bit LSB shared object, x86-64
    ```
    Используя `strace` выясните, где находится база данных `file` на основании которой она делает свои догадки.
    
    ` openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3`

    
1. Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
        
       echo "null" >/proc/PID/fd/№

3. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
  
       Зомби не занимают памяти (как процессы-сироты), но блокируют записи в таблице процессов, размер которой ограничен для каждого пользователя и системы в целом.
       При достижении лимита записей все процессы пользователя, от имени которого выполняется создающий зомби родительский процесс, не будут способны создавать новые дочерние процессы. 
       Кроме этого, пользователь, от имени которого выполняется родительский процесс, не сможет зайти на консоль  или выполнить какие-либо команды на уже открытой консоли, и для восстановления работоспособности будет необходимо вмешательство системного администратора.

5. В iovisor BCC есть утилита `opensnoop`:
    ```bash
    root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
    /usr/sbin/opensnoop-bpfcc
    ```
    На какие файлы вы увидели вызовы группы `open` за первую секунду работы утилиты? Воспользуйтесь пакетом `bpfcc-tools` для Ubuntu 20.04. Дополнительные [сведения по установке](https://github.com/iovisor/bcc/blob/master/INSTALL.md).
    
        vagrant@vagrant:~$ sudo /usr/sbin/opensnoop-bpfcc
        PID    COMM               FD ERR PATH
        773    vminfo              4   0 /var/run/utmp
        583    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
        583    dbus-daemon        18   0 /usr/share/dbus-1/system-services
        583    dbus-daemon        -1   2 /lib/dbus-1/system-services
        583    dbus-daemon        18   0 /var/lib/snapd/dbus-1/system-services/

1. Какой системный вызов использует `uname -a`? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в `/proc`, где можно узнать версию ядра и релиз ОС.

       Part of the utsname information is also accessible via
       /proc/sys/kernel/{ostype, hostname, osrelease, version,
       domainname}.
       
3. Чем отличается последовательность команд через `;` и через `&&` в bash? Например:
    ```bash
    root@netology1:~# test -d /tmp/some_dir; echo Hi
    Hi
    root@netology1:~# test -d /tmp/some_dir && echo Hi
    root@netology1:~#
    ```
    Есть ли смысл использовать в bash `&&`, если применить `set -e`?
    
    
        test -d /tmp/some_dir && echo Hi - в данном случае echo  отработает только при успешном заверщении команды test
        set -e - прерывает сессию при любом ненулевом значении исполняемых команд в конвеере кроме последней.
        Использовать `&&` не имеет смысла , если применить `set -e, т.к если будет ошибка- команда после && и так не отработает
        
       
1. Из каких опций состоит режим bash `set -euxo pipefail` и почему его хорошо было бы использовать в сценариях?
        
        -e  Exit immediately if a command exits with a non-zero status.
        -u  Treat unset variables as an error when substituting.
        -x  Print commands and their arguments as they are executed.
         -o option-name
              pipefail     the return value of a pipeline is the status of
                           the last command to exit with a non-zero status,
                           or zero if no command exited with a non-zero status
                           
        Завершает немедленно выполнение команд, если возникла ошибка. Считает неустановленные переменные ошибкой, печатает команды и аргументы по мере их выполнения, возвращает статус последней команды завершенной с ошибкой, либо 0
        Добавлять надо чтобы сценарии завершались при ошибке одной из команд и можно было вывести лог ошибок
    
3. Используя `-o stat` для `ps`, определите, какой наиболее часто встречающийся статус у процессов в системе. В `man ps` ознакомьтесь (`/PROCESS STATE CODES`) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).

            Ss - ожидают завершения
            R+ - запущенные или ожидающие запуск

---
